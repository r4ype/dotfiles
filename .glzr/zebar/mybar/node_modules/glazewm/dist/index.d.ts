import { MessageEvent, Event, CloseEvent, ErrorEvent } from 'ws';

declare enum DisplayState {
    SHOWN = "shown",
    SHOWING = "showing",
    HIDDEN = "hidden",
    HIDING = "hiding"
}

interface LengthUnit {
    amount: number;
    unit: 'pixel' | 'percentage';
}

interface RectDelta {
    left: LengthUnit;
    top: LengthUnit;
    right: LengthUnit;
    bottom: LengthUnit;
}

interface Rect {
    left: number;
    top: number;
    right: number;
    bottom: number;
}

declare enum TilingDirection {
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal"
}

declare enum WindowType {
    TILING = "tiling",
    FLOATING = "floating",
    MINIMIZED = "minimized",
    FULLSCREEN = "fullscreen"
}

type WindowState = {
    type: WindowType.FLOATING;
    centered: boolean;
    shownOnTop: boolean;
} | {
    type: WindowType.FULLSCREEN;
    maximized: boolean;
    shownOnTop: boolean;
} | {
    type: WindowType.MINIMIZED;
} | {
    type: WindowType.TILING;
};

interface KeybindingConfig {
    bindings: string[];
    command: unknown;
}

interface BindingModeConfig {
    name: string;
    displayName: string;
    keybindings: KeybindingConfig;
}

declare enum ContainerType {
    ROOT = "root",
    MONITOR = "monitor",
    WORKSPACE = "workspace",
    SPLIT = "split",
    WINDOW = "window"
}

interface Window {
    id: string;
    type: ContainerType.WINDOW;
    parentId: string;
    hasFocus: boolean;
    floatingPlacement: Rect;
    borderDelta: RectDelta;
    handle: number;
    tilingSize: number | null;
    state: WindowState;
    prevState: WindowState | null;
    displayState: DisplayState;
    title: string;
    processName: string;
    className: string;
    width: number;
    height: number;
    x: number;
    y: number;
}

interface SplitContainer {
    id: string;
    type: ContainerType.SPLIT;
    parentId: string;
    childFocusOrder: string[];
    children: (SplitContainer | Window)[];
    hasFocus: boolean;
    tilingDirection: TilingDirection;
    tilingSize: number;
    width: number;
    height: number;
    x: number;
    y: number;
}

interface Workspace {
    id: string;
    type: ContainerType.WORKSPACE;
    parentId: string;
    childFocusOrder: string[];
    children: (SplitContainer | Window)[];
    hasFocus: boolean;
    isDisplayed: boolean;
    name: string;
    displayName: string;
    tilingDirection: TilingDirection;
    width: number;
    height: number;
    x: number;
    y: number;
}

interface Monitor {
    id: string;
    type: ContainerType.MONITOR;
    parentId: string;
    childFocusOrder: string[];
    children: Workspace[];
    hasFocus: boolean;
    dpi: number;
    scaleFactor: number;
    width: number;
    height: number;
    x: number;
    y: number;
    handle: number;
    deviceName: string;
    devicePath: string | null;
    hardwareId: string | null;
    workingRect: Rect;
}

interface RootContainer {
    id: string;
    type: ContainerType.ROOT;
    parentId: null;
    childFocusOrder: string[];
    children: Monitor[];
}

type Container = RootContainer | Monitor | Workspace | SplitContainer | Window;

/**
 * All possible GlazeWM event types (e.g. `'focus_changed'`).
 */
declare enum WmEventType {
    ALL = "all",
    APPLICATION_EXITING = "application_exiting",
    BINDING_MODES_CHANGED = "binding_modes_changed",
    FOCUS_CHANGED = "focus_changed",
    FOCUSED_CONTAINER_MOVED = "focused_container_moved",
    MONITOR_ADDED = "monitor_added",
    MONITOR_UPDATED = "monitor_updated",
    MONITOR_REMOVED = "monitor_removed",
    TILING_DIRECTION_CHANGED = "tiling_direction_changed",
    USER_CONFIG_CHANGED = "user_config_changed",
    WINDOW_MANAGED = "window_managed",
    WINDOW_UNMANAGED = "window_unmanaged",
    WORKSPACE_ACTIVATED = "workspace_activated",
    WORKSPACE_DEACTIVATED = "workspace_deactivated",
    WORKSPACE_UPDATED = "workspace_updated",
    PAUSE_CHANGED = "pause_changed"
}
/**
 * All possible GlazeWM event interfaces.
 */
type WmEvent = ApplicationExitingEvent | BindingModesChangedEvent | FocusChangedEvent | FocusedContainerMovedEvent | MonitorAddedEvent | MonitorUpdatedEvent | MonitorRemovedEvent | TilingDirectionChangedEvent | UserConfigChangedEvent | WindowManagedEvent | WindowUnmanagedEvent | WorkspaceActivatedEvent | WorkspaceDeactivatedEvent | WorkspaceUpdatedEvent | PauseChangedEvent;
/**
 * Utility type for getting event interface for given {@link WmEventType}.
 *
 * @example
 * ```typescript
 * type Example = WmEventData<WmEventType.MONITOR_ADDED> // -> MonitorAddedEvent
 * ```
 */
type WmEventData<T extends WmEventType = WmEventType.ALL> = {
    [WmEventType.ALL]: WmEvent;
    [WmEventType.APPLICATION_EXITING]: ApplicationExitingEvent;
    [WmEventType.BINDING_MODES_CHANGED]: BindingModesChangedEvent;
    [WmEventType.FOCUS_CHANGED]: FocusChangedEvent;
    [WmEventType.FOCUSED_CONTAINER_MOVED]: FocusedContainerMovedEvent;
    [WmEventType.MONITOR_ADDED]: MonitorAddedEvent;
    [WmEventType.MONITOR_REMOVED]: MonitorRemovedEvent;
    [WmEventType.MONITOR_UPDATED]: MonitorUpdatedEvent;
    [WmEventType.TILING_DIRECTION_CHANGED]: TilingDirectionChangedEvent;
    [WmEventType.WINDOW_MANAGED]: WindowManagedEvent;
    [WmEventType.WINDOW_UNMANAGED]: WindowUnmanagedEvent;
    [WmEventType.USER_CONFIG_CHANGED]: UserConfigChangedEvent;
    [WmEventType.WORKSPACE_ACTIVATED]: WorkspaceActivatedEvent;
    [WmEventType.WORKSPACE_DEACTIVATED]: WorkspaceDeactivatedEvent;
    [WmEventType.WORKSPACE_UPDATED]: WorkspaceUpdatedEvent;
    [WmEventType.PAUSE_CHANGED]: PauseChangedEvent;
}[T];

interface ApplicationExitingEvent {
    eventType: WmEventType.APPLICATION_EXITING;
}

interface BindingModesChangedEvent {
    eventType: WmEventType.BINDING_MODES_CHANGED;
    newBindingModes: BindingModeConfig[];
}

interface FocusChangedEvent {
    eventType: WmEventType.FOCUS_CHANGED;
    focusedContainer: Window | Workspace;
}

interface FocusedContainerMovedEvent {
    eventType: WmEventType.FOCUSED_CONTAINER_MOVED;
    focusedContainer: Window | Workspace;
}

interface MonitorAddedEvent {
    eventType: WmEventType.MONITOR_ADDED;
    addedMonitor: Monitor;
}

interface MonitorRemovedEvent {
    eventType: WmEventType.MONITOR_REMOVED;
    removedId: string;
    removedDeviceName: string;
}

interface MonitorUpdatedEvent {
    eventType: WmEventType.MONITOR_UPDATED;
    updatedMonitor: Monitor;
}

interface PauseChangedEvent {
    eventType: WmEventType.PAUSE_CHANGED;
    isPaused: boolean;
}

interface TilingDirectionChangedEvent {
    eventType: WmEventType.TILING_DIRECTION_CHANGED;
    newTilingDirection: TilingDirection;
    directionContainer: SplitContainer | Workspace;
}

interface UserConfigChangedEvent {
    eventType: WmEventType.USER_CONFIG_CHANGED;
    configPath: string;
    configString: string;
    parsedConfig: any;
}

interface WindowManagedEvent {
    eventType: WmEventType.WINDOW_MANAGED;
    managedWindow: Window;
}

interface WindowUnmanagedEvent {
    eventType: WmEventType.WINDOW_UNMANAGED;
    unmanagedId: string;
    unmanagedHandle: number;
}

interface WorkspaceActivatedEvent {
    eventType: WmEventType.WORKSPACE_ACTIVATED;
    activatedWorkspace: Workspace;
}

interface WorkspaceDeactivatedEvent {
    eventType: WmEventType.WORKSPACE_DEACTIVATED;
    deactivatedId: string;
    deactivatedName: string;
}

interface WorkspaceUpdatedEvent {
    eventType: WmEventType.WORKSPACE_UPDATED;
    updatedWorkspace: Workspace;
}

interface AppMetadataResponse {
    version: string;
}

interface BindingModesResponse {
    bindingModes: BindingModeConfig[];
}

interface FocusedResponse {
    focused: Window | Workspace;
}

interface MonitorsResponse {
    monitors: Monitor[];
}

interface PausedResponse {
    paused: boolean;
}

interface RunCommandResponse {
    subjectContainerId: string;
}

interface SubscribeResponse {
    subscriptionId: string;
}

interface TilingDirectionResponse {
    tilingDirection: TilingDirection;
    directionContainer: Workspace | SplitContainer;
}

interface WindowsResponse {
    windows: Window[];
}

interface WorkspacesResponse {
    workspaces: Workspace[];
}

declare enum ServerMessageType {
    CLIENT_RESPONSE = "client_response",
    EVENT_SUBSCRIPTION = "event_subscription"
}
interface BaseServerMessage<T> {
    /**
     * Whether the server message has an associated error.
     */
    success: boolean;
    /**
     * The type of server message.
     */
    messageType: ServerMessageType;
    /**
     * The response or event data. This property is only present for messages
     * where `success` is `true`.
     */
    data: T | null;
    /**
     * The error message. This property is only present for messages where
     * `success` is `false`.
     */
    error: string | null;
}
interface ClientResponseMessage<T> extends BaseServerMessage<T> {
    messageType: ServerMessageType.CLIENT_RESPONSE;
    /**
     * The client message that this is in response to.
     */
    clientMessage: string;
}
interface EventSubscriptionMessage<T> extends BaseServerMessage<T> {
    messageType: ServerMessageType.EVENT_SUBSCRIPTION;
    /**
     * A unique identifier for the subscription.
     */
    subscriptionId: string;
}
type ServerMessage<T> = ClientResponseMessage<T> | EventSubscriptionMessage<T>;

interface WmClientOptions {
    /**
     * IPC server port to connect to.
     *
     * Defaults to `6123`.
     */
    port?: number;
    /**
     * Reconnection interval in milliseconds.
     *
     * Defaults to `5000` (5 seconds).
     */
    reconnectInterval?: number;
}
/** Unregisters a callback. */
type UnlistenFn = () => void;
type MessageCallback = (e: MessageEvent) => void;
type ConnectCallback = (e: Event) => void;
type DisconnectCallback = (e: CloseEvent) => void;
type ErrorCallback = (e: ErrorEvent) => void;
type SubscribeCallback<T extends WmEventType> = (data: WmEventData<T>) => void;
declare class WmClient {
    private _options?;
    private readonly DEFAULT_PORT;
    private readonly DEFAULT_RECONNECT_INTERVAL;
    /**
     * Promise that resolves to `WebSocket` instance if connected.
     *
     * Prevents duplicate connections.
     */
    private _socketPromise;
    /**
     * Whether the connection was closed via {@link closeConnection}.
     */
    private _isManuallyClosed;
    private _onMessageCallbacks;
    private _onConnectCallbacks;
    private _onDisconnectCallbacks;
    private _onErrorCallbacks;
    /**
     * Instantiates client and attempts to connect to IPC server.
     *
     * The client will automatically attempt to reconnect on disconnections,
     * configurable via {@link WmClientOptions.reconnectInterval}.
     */
    constructor(_options?: WmClientOptions | undefined);
    /**
     * Gets all monitors. {@link Monitor}
     *
     * @throws If connection to IPC server fails.
     */
    queryMonitors(): Promise<MonitorsResponse>;
    /**
     * Gets all active workspaces. {@link Workspace}
     *
     * @throws If connection to IPC server fails.
     */
    queryWorkspaces(): Promise<WorkspacesResponse>;
    /**
     * Gets all managed windows. {@link Window}
     *
     * @throws If connection to IPC server fails.
     */
    queryWindows(): Promise<WindowsResponse>;
    /**
     * Gets the currently focused container. This can either be a
     * {@link Window} or a {@link Workspace} without any descendant windows.
     *
     * @throws If connection to IPC server fails.
     */
    queryFocused(): Promise<FocusedResponse>;
    /**
     * Gets the active binding modes.
     *
     * @throws If connection to IPC server fails.
     */
    queryBindingModes(): Promise<BindingModesResponse>;
    /**
     * Gets metadata about the running GlazeWM application.
     *
     * @throws If connection to IPC server fails.
     */
    queryAppMetadata(): Promise<AppMetadataResponse>;
    /**
     * Gets the tiling direction of the focused container.
     *
     * @throws If connection to IPC server fails.
     */
    queryTilingDirection(): Promise<TilingDirectionResponse>;
    /**
     * Gets the current paused state.
     *
     * @throws If connection to IPC server fails.
     */
    queryPaused(): Promise<PausedResponse>;
    /**
     * Invokes a WM command (e.g. `"focus --workspace 1"`).
     *
     * @param command WM command to run (e.g. `"focus --workspace 1"`).
     * @param subjectContainerId (optional) ID of container to use as subject.
     * If not provided, this defaults to the currently focused container.
     * @throws If the command errors or connection to IPC server fails.
     */
    runCommand(command: string, subjectContainerId?: string): Promise<RunCommandResponse>;
    /**
     * Establishes websocket connection.
     *
     * @throws If connection to IPC server fails.
     */
    connect(): Promise<void>;
    /**
     * Closes the websocket connection.
     */
    closeConnection(): Promise<void>;
    /**
     * Registers a callback for a GlazeWM event type.
     *
     * Persists the subscription across reconnections.
     *
     * @example
     * ```typescript
     * const unlisten = await client.subscribe(
     *   WmEventType.FOCUS_CHANGED,
     *   (event: FocusChangedEvent) => { ... }
     * });
     * ```
     * @throws If *initial* connection to IPC server fails.
     */
    subscribe<T extends WmEventType>(event: T, callback: SubscribeCallback<T>): Promise<UnlistenFn>;
    /**
     * Registers a callback for multiple GlazeWM event types.
     *
     * Persists the subscription across reconnections.
     *
     * @example
     * ```typescript
     * const unlisten = await client.subscribeMany(
     *   [WmEventType.WORSPACE_ACTIVATED, WmEventType.WORSPACE_DEACTIVATED],
     *   (event: WorkspaceActivatedEvent | WorkspaceDeactivatedEvent) => { ... }
     * );
     * ```
     * @throws If *initial* connection to IPC server fails.
     */
    subscribeMany<T extends WmEventType[]>(events: T, callback: SubscribeCallback<T[number]>): Promise<UnlistenFn>;
    /**
     * Registers a callback for when websocket messages are received.
     *
     * @example
     * ```typescript
     * const unlisten = client.onDisconnect(e => console.log(e));
     * ```
     */
    onMessage(callback: MessageCallback): UnlistenFn;
    /**
     * Registers a callback for when the websocket connects or reconnects.
     *
     * @example
     * ```typescript
     * const unlisten = client.onDisconnect(e => console.log(e));
     * ```
     */
    onConnect(callback: ConnectCallback): UnlistenFn;
    /**
     * Registers a callback for when the websocket disconnects.
     *
     * @example
     * ```typescript
     * const unlisten = client.onDisconnect(e => console.log(e));
     * ```
     */
    onDisconnect(callback: DisconnectCallback): UnlistenFn;
    /**
     * Registers a callback for when the websocket connection has been closed
     * due to an error.
     *
     * @example
     * ```typescript
     * const unlisten = client.onError(e => console.error(e));
     * ```
     */
    onError(callback: ErrorCallback): UnlistenFn;
    /**
     * Sends an IPC message and waits for a reply.
     *
     * @private
     * @throws If message is invalid or connection to IPC server fails.
     */
    private _sendAndWaitReply;
    /**
     * Utility function for registering a callback.
     *
     * @private
     */
    private _registerCallback;
    /**
     * Instantiates `WebSocket` and adds event listeners for socket events.
     *
     * @private
     */
    private _createSocket;
    /**
     * Waits for the websocket connection to be established.
     *
     * @private
     * @throws On disconnect or close.
     */
    private _waitForConnection;
    /**
     * @private
     * @throws If connection to IPC server fails.
     */
    private _sendSubscribe;
    /**
     * @private
     * @throws If connection to IPC server fails.
     */
    private _sendUnsubscribe;
}

export { AppMetadataResponse, ApplicationExitingEvent, BindingModeConfig, BindingModesChangedEvent, BindingModesResponse, ClientResponseMessage, ConnectCallback, Container, ContainerType, DisconnectCallback, DisplayState, ErrorCallback, EventSubscriptionMessage, FocusChangedEvent, FocusedContainerMovedEvent, FocusedResponse, KeybindingConfig, LengthUnit, MessageCallback, Monitor, MonitorAddedEvent, MonitorRemovedEvent, MonitorUpdatedEvent, MonitorsResponse, PauseChangedEvent, PausedResponse, Rect, RectDelta, RootContainer, RunCommandResponse, ServerMessage, ServerMessageType, SplitContainer, SubscribeCallback, SubscribeResponse, TilingDirection, TilingDirectionChangedEvent, TilingDirectionResponse, UnlistenFn, UserConfigChangedEvent, Window, WindowManagedEvent, WindowState, WindowType, WindowUnmanagedEvent, WindowsResponse, WmClient, WmClientOptions, WmEvent, WmEventData, WmEventType, Workspace, WorkspaceActivatedEvent, WorkspaceDeactivatedEvent, WorkspaceUpdatedEvent, WorkspacesResponse };
