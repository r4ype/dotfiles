"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ContainerType: () => ContainerType,
  DisplayState: () => DisplayState,
  ServerMessageType: () => ServerMessageType,
  TilingDirection: () => TilingDirection,
  WindowType: () => WindowType,
  WmClient: () => WmClient,
  WmEventType: () => WmEventType
});
module.exports = __toCommonJS(src_exports);

// src/client.ts
var WmClient = class {
  /**
   * Instantiates client and attempts to connect to IPC server.
   *
   * The client will automatically attempt to reconnect on disconnections,
   * configurable via {@link WmClientOptions.reconnectInterval}.
   */
  constructor(_options) {
    this._options = _options;
    this.connect().catch(() => {
    });
  }
  DEFAULT_PORT = 6123;
  DEFAULT_RECONNECT_INTERVAL = 5e3;
  /**
   * Promise that resolves to `WebSocket` instance if connected.
   *
   * Prevents duplicate connections.
   */
  _socketPromise = null;
  /**
   * Whether the connection was closed via {@link closeConnection}.
   */
  _isManuallyClosed = false;
  _onMessageCallbacks = [];
  _onConnectCallbacks = [];
  _onDisconnectCallbacks = [];
  _onErrorCallbacks = [];
  /**
   * Gets all monitors. {@link Monitor}
   *
   * @throws If connection to IPC server fails.
   */
  async queryMonitors() {
    return this._sendAndWaitReply("query monitors");
  }
  /**
   * Gets all active workspaces. {@link Workspace}
   *
   * @throws If connection to IPC server fails.
   */
  async queryWorkspaces() {
    return this._sendAndWaitReply("query workspaces");
  }
  /**
   * Gets all managed windows. {@link Window}
   *
   * @throws If connection to IPC server fails.
   */
  async queryWindows() {
    return this._sendAndWaitReply("query windows");
  }
  /**
   * Gets the currently focused container. This can either be a
   * {@link Window} or a {@link Workspace} without any descendant windows.
   *
   * @throws If connection to IPC server fails.
   */
  async queryFocused() {
    return this._sendAndWaitReply("query focused");
  }
  /**
   * Gets the active binding modes.
   *
   * @throws If connection to IPC server fails.
   */
  async queryBindingModes() {
    return this._sendAndWaitReply(
      "query binding-modes"
    );
  }
  /**
   * Gets metadata about the running GlazeWM application.
   *
   * @throws If connection to IPC server fails.
   */
  async queryAppMetadata() {
    return this._sendAndWaitReply(
      "query app-metadata"
    );
  }
  /**
   * Gets the tiling direction of the focused container.
   *
   * @throws If connection to IPC server fails.
   */
  async queryTilingDirection() {
    return this._sendAndWaitReply(
      "query tiling-direction"
    );
  }
  /**
   * Gets the current paused state.
   *
   * @throws If connection to IPC server fails.
   */
  async queryPaused() {
    return this._sendAndWaitReply("query paused");
  }
  /**
   * Invokes a WM command (e.g. `"focus --workspace 1"`).
   *
   * @param command WM command to run (e.g. `"focus --workspace 1"`).
   * @param subjectContainerId (optional) ID of container to use as subject.
   * If not provided, this defaults to the currently focused container.
   * @throws If the command errors or connection to IPC server fails.
   */
  async runCommand(command, subjectContainerId) {
    return this._sendAndWaitReply(
      subjectContainerId ? `command --id ${subjectContainerId} ${command}` : `command ${command}`
    );
  }
  /**
   * Establishes websocket connection.
   *
   * @throws If connection to IPC server fails.
   */
  async connect() {
    this._isManuallyClosed = false;
    this._socketPromise ??= this._createSocket();
    await this._waitForConnection();
  }
  /**
   * Closes the websocket connection.
   */
  async closeConnection() {
    this._isManuallyClosed = true;
    (await this._socketPromise)?.close();
  }
  /**
   * Registers a callback for a GlazeWM event type.
   *
   * Persists the subscription across reconnections.
   *
   * @example
   * ```typescript
   * const unlisten = await client.subscribe(
   *   WmEventType.FOCUS_CHANGED,
   *   (event: FocusChangedEvent) => { ... }
   * });
   * ```
   * @throws If *initial* connection to IPC server fails.
   */
  async subscribe(event, callback) {
    return this.subscribeMany([event], callback);
  }
  /**
   * Registers a callback for multiple GlazeWM event types.
   *
   * Persists the subscription across reconnections.
   *
   * @example
   * ```typescript
   * const unlisten = await client.subscribeMany(
   *   [WmEventType.WORSPACE_ACTIVATED, WmEventType.WORSPACE_DEACTIVATED],
   *   (event: WorkspaceActivatedEvent | WorkspaceDeactivatedEvent) => { ... }
   * );
   * ```
   * @throws If *initial* connection to IPC server fails.
   */
  async subscribeMany(events, callback) {
    let subscriptionId = await this._sendSubscribe(events);
    const unlistenMessage = this.onMessage((e) => {
      const serverMessage = JSON.parse(
        e.data
      );
      const isSubscribedEvent = serverMessage.messageType === "event_subscription" && serverMessage.subscriptionId === subscriptionId;
      if (isSubscribedEvent) {
        callback(serverMessage.data);
      }
    });
    const unlistenConnect = this.onConnect(async (e) => {
      this._sendUnsubscribe(subscriptionId);
      subscriptionId = await this._sendSubscribe(events);
    });
    return async () => {
      unlistenMessage();
      unlistenConnect();
      await this._sendUnsubscribe(subscriptionId);
    };
  }
  /**
   * Registers a callback for when websocket messages are received.
   *
   * @example
   * ```typescript
   * const unlisten = client.onDisconnect(e => console.log(e));
   * ```
   */
  onMessage(callback) {
    return this._registerCallback(this._onMessageCallbacks, callback);
  }
  /**
   * Registers a callback for when the websocket connects or reconnects.
   *
   * @example
   * ```typescript
   * const unlisten = client.onDisconnect(e => console.log(e));
   * ```
   */
  onConnect(callback) {
    return this._registerCallback(this._onConnectCallbacks, callback);
  }
  /**
   * Registers a callback for when the websocket disconnects.
   *
   * @example
   * ```typescript
   * const unlisten = client.onDisconnect(e => console.log(e));
   * ```
   */
  onDisconnect(callback) {
    return this._registerCallback(this._onDisconnectCallbacks, callback);
  }
  /**
   * Registers a callback for when the websocket connection has been closed
   * due to an error.
   *
   * @example
   * ```typescript
   * const unlisten = client.onError(e => console.error(e));
   * ```
   */
  onError(callback) {
    return this._registerCallback(this._onErrorCallbacks, callback);
  }
  /**
   * Sends an IPC message and waits for a reply.
   *
   * @private
   * @throws If message is invalid or connection to IPC server fails.
   */
  async _sendAndWaitReply(message) {
    if (this._isManuallyClosed) {
      throw new Error(
        "Websocket connection was closed via `closeConnection`."
      );
    }
    await this.connect();
    const socket = await this._socketPromise;
    return new Promise(async (resolve, reject) => {
      socket.send(message, (error) => {
        if (error) {
          reject(error);
        }
      });
      const unlisten = this.onMessage((e) => {
        const serverMessage = JSON.parse(
          e.data
        );
        const isReplyMessage = serverMessage.messageType === "client_response" && serverMessage.clientMessage === message;
        if (isReplyMessage) {
          unlisten();
          if (serverMessage.error) {
            reject(serverMessage.error);
          } else {
            resolve(serverMessage.data);
          }
        }
      });
    });
  }
  /**
   * Utility function for registering a callback.
   *
   * @private
   */
  _registerCallback(callbacks, newCallback) {
    callbacks.push(newCallback);
    return () => {
      for (const [index, callback] of callbacks.entries()) {
        if (callback === newCallback) {
          callbacks.splice(index, 1);
        }
      }
    };
  }
  /**
   * Instantiates `WebSocket` and adds event listeners for socket events.
   *
   * @private
   */
  async _createSocket() {
    const WebSocketApi = await (globalThis.WebSocket ?? import("ws").then((ws) => ws.default).catch(() => {
      throw new Error(
        "The dependency 'ws' is required for environments without abuilt-in WebSocket API. \nRun `npm i ws` to resolve thiserror."
      );
    }));
    const socket = new WebSocketApi(
      `ws://localhost:${this._options?.port ?? this.DEFAULT_PORT}`
    );
    socket.onmessage = (e) => this._onMessageCallbacks.forEach((callback) => callback(e));
    socket.onopen = (e) => this._onConnectCallbacks.forEach((callback) => callback(e));
    socket.onerror = (e) => this._onErrorCallbacks.forEach((callback) => callback(e));
    socket.onclose = (e) => {
      this._onDisconnectCallbacks.forEach((callback) => callback(e));
      if (!this._isManuallyClosed) {
        setTimeout(
          () => this._socketPromise = this._createSocket(),
          this._options?.reconnectInterval ?? this.DEFAULT_RECONNECT_INTERVAL
        );
      }
    };
    return socket;
  }
  /**
   * Waits for the websocket connection to be established.
   *
   * @private
   * @throws On disconnect or close.
   */
  async _waitForConnection() {
    const socket = await this._socketPromise;
    if (!socket || socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) {
      throw new Error("Websocket connection is closed.");
    }
    if (socket.readyState === socket.OPEN) {
      return socket;
    }
    return new Promise(async (resolve, reject) => {
      function cleanup() {
        if (unlistenConnect)
          unlistenConnect();
        if (unlistenDisconnect)
          unlistenDisconnect();
      }
      const unlistenConnect = this.onConnect(() => {
        cleanup();
        resolve(socket);
      });
      const unlistenDisconnect = this.onDisconnect(() => {
        cleanup();
        reject(new Error("Failed to establish websocket connection."));
      });
    });
  }
  /**
   * @private
   * @throws If connection to IPC server fails.
   */
  async _sendSubscribe(events) {
    const { subscriptionId } = await this._sendAndWaitReply(
      `sub --events ${events.join(" ")}`
    );
    return subscriptionId;
  }
  /**
   * @private
   * @throws If connection to IPC server fails.
   */
  async _sendUnsubscribe(subscriptionId) {
    await this._sendAndWaitReply(`unsub --id ${subscriptionId}`);
  }
};

// src/types/common/display-state.ts
var DisplayState = /* @__PURE__ */ ((DisplayState2) => {
  DisplayState2["SHOWN"] = "shown";
  DisplayState2["SHOWING"] = "showing";
  DisplayState2["HIDDEN"] = "hidden";
  DisplayState2["HIDING"] = "hiding";
  return DisplayState2;
})(DisplayState || {});

// src/types/common/tiling-direction.ts
var TilingDirection = /* @__PURE__ */ ((TilingDirection2) => {
  TilingDirection2["VERTICAL"] = "vertical";
  TilingDirection2["HORIZONTAL"] = "horizontal";
  return TilingDirection2;
})(TilingDirection || {});

// src/types/common/window-type.ts
var WindowType = /* @__PURE__ */ ((WindowType2) => {
  WindowType2["TILING"] = "tiling";
  WindowType2["FLOATING"] = "floating";
  WindowType2["MINIMIZED"] = "minimized";
  WindowType2["FULLSCREEN"] = "fullscreen";
  return WindowType2;
})(WindowType || {});

// src/types/containers/container-type.ts
var ContainerType = /* @__PURE__ */ ((ContainerType2) => {
  ContainerType2["ROOT"] = "root";
  ContainerType2["MONITOR"] = "monitor";
  ContainerType2["WORKSPACE"] = "workspace";
  ContainerType2["SPLIT"] = "split";
  ContainerType2["WINDOW"] = "window";
  return ContainerType2;
})(ContainerType || {});

// src/types/server-message.ts
var ServerMessageType = /* @__PURE__ */ ((ServerMessageType2) => {
  ServerMessageType2["CLIENT_RESPONSE"] = "client_response";
  ServerMessageType2["EVENT_SUBSCRIPTION"] = "event_subscription";
  return ServerMessageType2;
})(ServerMessageType || {});

// src/types/wm-events.ts
var WmEventType = /* @__PURE__ */ ((WmEventType2) => {
  WmEventType2["ALL"] = "all";
  WmEventType2["APPLICATION_EXITING"] = "application_exiting";
  WmEventType2["BINDING_MODES_CHANGED"] = "binding_modes_changed";
  WmEventType2["FOCUS_CHANGED"] = "focus_changed";
  WmEventType2["FOCUSED_CONTAINER_MOVED"] = "focused_container_moved";
  WmEventType2["MONITOR_ADDED"] = "monitor_added";
  WmEventType2["MONITOR_UPDATED"] = "monitor_updated";
  WmEventType2["MONITOR_REMOVED"] = "monitor_removed";
  WmEventType2["TILING_DIRECTION_CHANGED"] = "tiling_direction_changed";
  WmEventType2["USER_CONFIG_CHANGED"] = "user_config_changed";
  WmEventType2["WINDOW_MANAGED"] = "window_managed";
  WmEventType2["WINDOW_UNMANAGED"] = "window_unmanaged";
  WmEventType2["WORKSPACE_ACTIVATED"] = "workspace_activated";
  WmEventType2["WORKSPACE_DEACTIVATED"] = "workspace_deactivated";
  WmEventType2["WORKSPACE_UPDATED"] = "workspace_updated";
  WmEventType2["PAUSE_CHANGED"] = "pause_changed";
  return WmEventType2;
})(WmEventType || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ContainerType,
  DisplayState,
  ServerMessageType,
  TilingDirection,
  WindowType,
  WmClient,
  WmEventType
});
