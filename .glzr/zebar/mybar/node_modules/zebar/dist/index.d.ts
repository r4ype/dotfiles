import { Workspace, Monitor, Window, Container, TilingDirection, BindingModeConfig, RunCommandResponse } from 'glazewm';
import { getCurrentWindow } from '@tauri-apps/api/window';

type MonitorSelection = {
    type: 'all' | 'primary' | 'secondary';
};

type DockConfig = {
    enabled: boolean;
    edge: 'top' | 'bottom' | 'left' | 'right' | null;
    windowMargin: string;
};

type WidgetPlacement = {
    anchor: 'top_left' | 'top_center' | 'top_right' | 'center' | 'bottom_left' | 'bottom_center' | 'bottom_right';
    offsetX: string;
    offsetY: string;
    width: string;
    height: string;
    monitorSelection: MonitorSelection;
    dockToEdge: DockConfig;
};

type WidgetPreset = {
    name: string;
} & WidgetPlacement;

type WidgetConfig = {
    htmlPath: string;
    zOrder: 'normal' | 'top_most' | 'bottom_most';
    shownInTaskbar: boolean;
    focused: boolean;
    resizable: boolean;
    transparent: boolean;
    presets: WidgetPreset[];
};

interface AudioProviderConfig {
    type: 'audio';
}
type AudioProvider = Provider<AudioProviderConfig, AudioOutput>;
interface AudioOutput {
    defaultPlaybackDevice: AudioDevice | null;
    defaultRecordingDevice: AudioDevice | null;
    playbackDevices: AudioDevice[];
    recordingDevices: AudioDevice[];
    setVolume(volume: number, options?: SetVolumeOptions): Promise<void>;
}
interface SetVolumeOptions {
    deviceId?: string;
}
interface AudioDevice {
    deviceId: string;
    name: string;
    volume: number;
    type: AudioDeviceType;
    isDefaultPlayback: boolean;
    isDefaultRecording: boolean;
}
type AudioDeviceType = 'playback' | 'recording';

interface CpuProviderConfig {
    type: 'cpu';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type CpuProvider = Provider<CpuProviderConfig, CpuOutput>;
interface CpuOutput {
    frequency: number;
    usage: number;
    logicalCoreCount: number;
    physicalCoreCount: number;
    vendor: string;
}

interface DateProviderConfig {
    type: 'date';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
    /**
     * Either a UTC offset (eg. `UTC+8`) or an IANA timezone (eg.
     * `America/New_York`). Affects the output of {@link DateOutput.formatted}.
     *
     * A full list of available IANA timezones can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
     */
    timezone?: string;
    /**
     * An ISO-639-1 locale, which is either a 2-letter language code
     * (eg. `en`) or a 4-letter language + country code (eg. `en-gb`).
     * Affects the output of {@link DateOutput.formatted}.
     *
     * A full list of ISO-639-1 locales can be found [here](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes#Table).
     */
    locale?: string;
    /**
     * Formatting of the current date into a custom string format. Affects
     * the output of {@link DateOutput.formatted}.
     *
     * Refer to [table of tokens](https://moment.github.io/luxon/#/formatting?id=table-of-tokens)
     * for available date/time tokens.
     *
     * @example
     * "yyyy LLL dd" -> "2023 Feb 13"
     * "HH 'hours and' mm 'minutes'" -> "20 hours and 55 minutes"
     */
    formatting?: string;
}
type DateProvider = Provider<DateProviderConfig, DateOutput>;
interface DateOutput {
    /**
     * Current date/time as a formatted string.
     */
    formatted: string;
    /**
     * Current date/time as a JavaScript `Date` object. Uses `new Date()` under
     * the hood.
     **/
    new: Date;
    /**
     * Current date/time as milliseconds since epoch. Uses `Date.now()` under the
     * hood.
     **/
    now: number;
    /**
     * Current date/time as an ISO-8601 string (eg.
     * `2017-04-22T20:47:05.335-04:00`). Uses `date.toISOString()` under the hood.
     **/
    iso: string;
}

interface GlazeWmProviderConfig {
    type: 'glazewm';
}
type GlazeWmProvider = Provider<GlazeWmProviderConfig, GlazeWmOutput>;
interface GlazeWmOutput {
    /**
     * Workspace displayed on the current monitor.
     */
    displayedWorkspace: Workspace;
    /**
     * Workspace that currently has focus (on any monitor).
     */
    focusedWorkspace: Workspace;
    /**
     * Workspaces on the current monitor.
     */
    currentWorkspaces: Workspace[];
    /**
     * Workspaces across all monitors.
     */
    allWorkspaces: Workspace[];
    /**
     * All monitors.
     */
    allMonitors: Monitor[];
    /**
     * All windows.
     */
    allWindows: Window[];
    /**
     * Monitor that currently has focus.
     */
    focusedMonitor: Monitor;
    /**
     * Monitor that is nearest to this Zebar widget.
     */
    currentMonitor: Monitor;
    /**
     * Container that currently has focus (on any monitor).
     */
    focusedContainer: Container;
    /**
     * Tiling direction of the focused container.
     */
    tilingDirection: TilingDirection;
    /**
     * Active binding modes;
     */
    bindingModes: BindingModeConfig[];
    /**
     * Invokes a WM command (e.g. `"focus --workspace 1"`).
     *
     * @param command WM command to run (e.g. `"focus --workspace 1"`).
     * @param subjectContainerId (optional) ID of container to use as subject.
     * If not provided, this defaults to the currently focused container.
     * @throws If command fails.
     */
    runCommand(command: string, subjectContainerId?: string): Promise<RunCommandResponse>;
}

interface HostProviderConfig {
    type: 'host';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type HostProvider = Provider<HostProviderConfig, HostOutput>;
interface HostOutput {
    hostname: string | null;
    osName: string | null;
    osVersion: string | null;
    friendlyOsVersion: string | null;
    bootTime: number;
    uptime: number;
}

interface IpProviderConfig {
    type: 'ip';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type IpProvider = Provider<IpProviderConfig, IpOutput>;
interface IpOutput {
    address: string;
    approxCity: string;
    approxCountry: string;
    approxLatitude: number;
    approxLongitude: number;
}

interface KeyboardProviderConfig {
    type: 'keyboard';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type KeyboardProvider = Provider<KeyboardProviderConfig, KeyboardOutput>;
interface KeyboardOutput {
    layout: string;
}

interface KomorebiProviderConfig {
    type: 'komorebi';
}
type KomorebiProvider = Provider<KomorebiProviderConfig, KomorebiOutput>;
interface KomorebiOutput {
    /**
     * Workspace displayed on the current monitor.
     */
    displayedWorkspace: KomorebiWorkspace;
    /**
     * Workspace that currently has focus (on any monitor).
     */
    focusedWorkspace: KomorebiWorkspace;
    /**
     * Workspaces on the current monitor.
     */
    currentWorkspaces: KomorebiWorkspace[];
    /**
     * Workspaces across all monitors.
     */
    allWorkspaces: KomorebiWorkspace[];
    /**
     * All monitors.
     */
    allMonitors: KomorebiMonitor[];
    /**
     * Monitor that currently has focus.
     */
    focusedMonitor: KomorebiMonitor;
    /**
     * Monitor that is nearest to this Zebar widget.
     */
    currentMonitor: KomorebiMonitor;
}
interface KomorebiResponse {
    allMonitors: KomorebiMonitor[];
    focusedMonitorIndex: number;
}
interface KomorebiMonitor {
    id: number;
    deviceId: string;
    focusedWorkspaceIndex: number;
    name: string;
    size: KomorebiRect;
    workAreaOffset: number | null;
    workAreaSize: KomorebiRect;
    workspaces: KomorebiWorkspace[];
}
interface KomorebiWorkspace {
    containerPadding: number | null;
    floatingWindows: KomorebiWindow[];
    focusedContainerIndex: number;
    latestLayout: KomorebiRect[];
    layout: KomorebiLayout;
    layoutFlip: KomorebiLayoutFlip | null;
    maximizedWindow: KomorebiWindow | null;
    monocleContainer: KomorebiContainer | null;
    name: string | null;
    tilingContainers: KomorebiContainer[];
    workspacePadding: number | null;
}
interface KomorebiContainer {
    id: string;
    windows: KomorebiWindow[];
}
interface KomorebiWindow {
    class: string | null;
    exe: string | null;
    hwnd: number;
    title: string | null;
}
interface KomorebiRect {
    left: number;
    top: number;
    right: number;
    bottom: number;
}
type KomorebiLayout = 'bsp' | 'vertical_stack' | 'horizontal_stack' | 'ultrawide_vertical_stack' | 'rows' | 'grid' | 'right_main_vertical_stack' | 'custom';
type KomorebiLayoutFlip = 'horizontal' | 'vertical' | 'horizontal_and_vertical';

interface MediaProviderConfig {
    type: 'media';
}
interface MediaOutput {
    /** @deprecated Use {@link currentSession} instead */
    session: MediaSession | null;
    currentSession: MediaSession | null;
    allSessions: MediaSession[];
    play(options?: MediaControlOptions): void;
    pause(options?: MediaControlOptions): void;
    togglePlayPause(options?: MediaControlOptions): void;
    next(options?: MediaControlOptions): void;
    previous(options?: MediaControlOptions): void;
}
interface MediaControlOptions {
    sessionId?: string;
}
interface MediaSession {
    sessionId: string;
    title: string | null;
    artist: string | null;
    albumTitle: string | null;
    albumArtist: string | null;
    trackNumber: number;
    startTime: number;
    endTime: number;
    position: number;
    isPlaying: boolean;
    isCurrentSession: boolean;
}
type MediaProvider = Provider<MediaProviderConfig, MediaOutput>;

interface MemoryProviderConfig {
    type: 'memory';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type MemoryProvider = Provider<MemoryProviderConfig, MemoryOutput>;
interface MemoryOutput {
    usage: number;
    freeMemory: number;
    usedMemory: number;
    totalMemory: number;
    freeSwap: number;
    usedSwap: number;
    totalSwap: number;
}

interface DataSizeMeasure {
    bytes: number;
    siValue: number;
    siUnit: string;
    iecValue: number;
    iecUnit: string;
}

interface NetworkProviderConfig {
    type: 'network';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type NetworkProvider = Provider<NetworkProviderConfig, NetworkOutput>;
interface NetworkOutput {
    defaultInterface: NetworkInterface | null;
    defaultGateway: NetworkGateway | null;
    interfaces: NetworkInterface[];
    traffic: NetworkTraffic | null;
}
interface NetworkInterface {
    name: string;
    friendlyName: string | null;
    description: string | null;
    type: InterfaceType;
    ipv4Addresses: string[];
    ipv6Addresses: string[];
    macAddress: string | null;
    transmitSeed: number | null;
    receiveSpeed: number | null;
    dnsServers: string[];
    isDefault: boolean;
}
interface NetworkGateway {
    macAddress: string;
    ipv4Addresses: string[];
    ipv6Addresses: string[];
    ssid: string | null;
    signalStrength: number | null;
}
type InterfaceType = 'unknown' | 'ethernet' | 'token_ring' | 'fddi' | 'ppp' | 'loopback' | 'slip' | 'atm' | 'generic_modem' | 'isdn' | 'wifi' | 'dsl' | 'tunnel' | 'high_performance_serial_bus' | 'mobile_broadband' | 'bridge';
interface NetworkTraffic {
    received: DataSizeMeasure;
    totalReceived: DataSizeMeasure;
    transmitted: DataSizeMeasure;
    totalTransmitted: DataSizeMeasure;
}

interface WeatherProviderConfig {
    type: 'weather';
    /**
     * Latitude to retrieve weather for. If not provided, latitude is instead
     * estimated based on public IP.
     */
    latitude?: number;
    /**
     * Longitude to retrieve weather for. If not provided, longitude is instead
     * estimated based on public IP.
     */
    longitude?: number;
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type WeatherProvider = Provider<WeatherProviderConfig, WeatherOutput>;
interface WeatherOutput {
    isDaytime: boolean;
    status: WeatherStatus;
    celsiusTemp: number;
    fahrenheitTemp: number;
    windSpeed: number;
}
type WeatherStatus = 'clear_day' | 'clear_night' | 'cloudy_day' | 'cloudy_night' | 'light_rain_day' | 'light_rain_night' | 'heavy_rain_day' | 'heavy_rain_night' | 'snow_day' | 'snow_night' | 'thunder_day' | 'thunder_night';

interface DiskProviderConfig {
    type: 'disk';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type DiskProvider = Provider<DiskProviderConfig, DiskOutput>;
interface Disk {
    name: string | null;
    fileSystem: string;
    mountPoint: string;
    totalSpace: DataSizeMeasure;
    availableSpace: DataSizeMeasure;
    isRemovable: boolean;
    driveType: string;
}
interface DiskOutput {
    disks: Disk[];
}

interface ProviderConfigMap {
    audio: AudioProviderConfig;
    battery: BatteryProviderConfig;
    cpu: CpuProviderConfig;
    date: DateProviderConfig;
    glazewm: GlazeWmProviderConfig;
    host: HostProviderConfig;
    ip: IpProviderConfig;
    komorebi: KomorebiProviderConfig;
    media: MediaProviderConfig;
    memory: MemoryProviderConfig;
    network: NetworkProviderConfig;
    weather: WeatherProviderConfig;
    keyboard: KeyboardProviderConfig;
    disk: DiskProviderConfig;
}
interface ProviderMap {
    audio: AudioProvider;
    battery: BatteryProvider;
    cpu: CpuProvider;
    date: DateProvider;
    glazewm: GlazeWmProvider;
    host: HostProvider;
    ip: IpProvider;
    komorebi: KomorebiProvider;
    media: MediaProvider;
    memory: MemoryProvider;
    network: NetworkProvider;
    weather: WeatherProvider;
    keyboard: KeyboardProvider;
    disk: DiskProvider;
}
type ProviderType = keyof ProviderConfigMap;
type ProviderConfig = ProviderConfigMap[keyof ProviderConfigMap];
type ProviderOutput = ProviderMap[keyof ProviderMap]['output'];
/**
 * Creates a provider, which is a collection of functions and variables
 * that can change over time. Alternatively, multiple providers can be
 * created using {@link createProviderGroup}.
 *
 * The provider will continue to output until its `stop` function is
 * called.
 *
 * @throws If the provider config is invalid. Errors are emitted via the
 * `onError` method.
 */
declare function createProvider<T extends ProviderConfig>(config: T): ProviderMap[T['type']];

interface Provider<TConfig, TOutput> {
    /**
     * Latest output emitted from the provider.
     *
     * `null` if the latest emission from the provider is an error.
     */
    output: TOutput | null;
    /**
     * Latest error message emitted from the provider.
     *
     * `null` if the latest emission from the provider is a valid output.
     */
    error: string | null;
    /**
     * Whether the latest emission from the provider is an error.
     */
    hasError: boolean;
    /**
     * Underlying config for the provider.
     */
    config: TConfig;
    /**
     * Restarts the provider.
     */
    restart(): Promise<void>;
    /**
     * Stops the provider.
     */
    stop(): Promise<void>;
    /**
     * Listens for outputs from the provider.
     *
     * @param callback - Callback to run when an output is emitted.
     */
    onOutput(callback: (output: TOutput) => void): void;
    /**
     * Listens for errors from the provider.
     *
     * @param callback - Callback to run when an error is emitted.
     */
    onError(callback: (error: string) => void): void;
}

interface BatteryProviderConfig {
    type: 'battery';
    /**
     * How often this provider refreshes in milliseconds.
     */
    refreshInterval?: number;
}
type BatteryProvider = Provider<BatteryProviderConfig, BatteryOutput>;
interface BatteryOutput {
    chargePercent: number;
    cycleCount: number;
    healthPercent: number;
    powerConsumption: number;
    state: 'discharging' | 'charging' | 'full' | 'empty' | 'unknown';
    isCharging: boolean;
    timeTillEmpty: number | null;
    timeTillFull: number | null;
    voltage: number | null;
}

/**
 * Config for creating multiple provider instances at once.
 *
 * Keys are unique identifiers for the provider instance, values are their
 * respective configs.
 */
type ProviderGroupConfig = {
    [name: string]: ProviderConfig;
};
type ProviderGroup<T extends ProviderGroupConfig> = {
    /**
     * A map of combined provider outputs. Each key corresponds to a provider
     * name, and each value is the output of that provider.
     */
    outputMap: {
        [TName in keyof T]: ProviderMap[T[TName]['type']]['output'];
    };
    /**
     * A map of combined provider errors. Each key corresponds to a provider
     * name, and each value is the error of that provider.
     */
    errorMap: {
        [TName in keyof T]: ProviderMap[T[TName]['type']]['error'];
    };
    /**
     * Whether the latest emission from any provider in the group is an
     * error.
     */
    hasErrors: boolean;
    /**
     * Underlying providers in the group.
     */
    raw: {
        [TName in keyof T]: ProviderMap[T[TName]['type']];
    };
    /**
     * Config for the provider group.
     */
    configMap: T;
    /**
     * Listens for outputs from any provider in the group.
     *
     * @param callback - Callback to run when an output is emitted.
     */
    onOutput: (callback: (outputMap: ProviderGroup<T>['outputMap']) => void) => void;
    /**
     * Listens for errors from any provider in the group.
     *
     * @param callback - Callback to run when an error is emitted.
     */
    onError: (callback: (errorMap: ProviderGroup<T>['errorMap']) => void) => void;
    /**
     * Restarts all providers in the group.
     */
    restartAll(): Promise<void>;
    /**
     * Stops all providers in the group.
     */
    stopAll(): Promise<void>;
};
/**
 * Creates multiple providers at once. A provider is a collection of
 * functions and variables that can change over time. Alternatively, a
 * single provider can be created using {@link createProvider}.
 */
declare function createProviderGroup<T extends ProviderGroupConfig>(configMap: T): ProviderGroup<T>;

type ZOrder = 'bottom_most' | 'top_most' | 'normal';
interface WidgetWindow {
    /**
     * The underlying Tauri window.
     */
    readonly tauri: ReturnType<typeof getCurrentWindow>;
    /**
     * Sets the z-order of the Tauri window.
     */
    setZOrder(zOrder: ZOrder): Promise<void>;
}

interface Widget {
    /**
     * Unique identifier for the widget instance.
     */
    id: string;
    /**
     * Absolute path to the widget's config file.
     */
    configPath: string;
    /**
     * Absolute path to the widget's HTML file.
     */
    htmlPath: string;
    /**
     * The window of the widget.
     */
    window: WidgetWindow;
}
declare function currentWidget(): Widget;
/**
 * Opens a widget by its config path and chosen placement.
 *
 * Config path is relative within the Zebar config directory.
 */
declare function startWidget(configPath: string, placement: WidgetPlacement): Promise<void>;
/**
 * Opens a widget by its config path and a preset name.
 *
 * Config path is relative within the Zebar config directory.
 */
declare function startWidgetPreset(configPath: string, presetName: string): Promise<void>;

export { type BatteryOutput, type BatteryProvider, type BatteryProviderConfig, type CpuOutput, type CpuProvider, type CpuProviderConfig, type DateOutput, type DateProvider, type DateProviderConfig, type Disk, type DiskOutput, type DiskProvider, type DiskProviderConfig, type DockConfig, type GlazeWmOutput, type GlazeWmProvider, type GlazeWmProviderConfig, type HostOutput, type HostProvider, type HostProviderConfig, type InterfaceType, type IpOutput, type IpProvider, type IpProviderConfig, type KeyboardOutput, type KeyboardProvider, type KeyboardProviderConfig, type KomorebiContainer, type KomorebiLayout, type KomorebiLayoutFlip, type KomorebiMonitor, type KomorebiOutput, type KomorebiProvider, type KomorebiProviderConfig, type KomorebiRect, type KomorebiResponse, type KomorebiWindow, type KomorebiWorkspace, type MediaControlOptions, type MediaOutput, type MediaProvider, type MediaProviderConfig, type MediaSession, type MemoryOutput, type MemoryProvider, type MemoryProviderConfig, type MonitorSelection, type NetworkGateway, type NetworkInterface, type NetworkOutput, type NetworkProvider, type NetworkProviderConfig, type NetworkTraffic, type ProviderConfig, type ProviderConfigMap, type ProviderGroup, type ProviderGroupConfig, type ProviderMap, type ProviderOutput, type ProviderType, type WeatherOutput, type WeatherProvider, type WeatherProviderConfig, type WeatherStatus, type Widget, type WidgetConfig, type WidgetPlacement, type WidgetPreset, type WidgetWindow, createProvider, createProviderGroup, currentWidget, startWidget, startWidgetPreset };
