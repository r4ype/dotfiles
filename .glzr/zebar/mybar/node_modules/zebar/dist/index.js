// src/desktop/desktop-commands.ts
import {
  invoke as tauriInvoke
} from "@tauri-apps/api/core";

// src/utils/create-logger.ts
function createLogger(section) {
  function log(consoleLogMethod, message, ...data) {
    const date = /* @__PURE__ */ new Date();
    const timestamp = `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}:${date.getMilliseconds().toString().padStart(3, "0")}`;
    const clonedData = data.map(tryClone);
    console[consoleLogMethod](
      `%c${timestamp}%c [${section}] %c${message}`,
      "color: #f5f9b4",
      "color: #d0b4f9",
      "color: inherit",
      ...clonedData
    );
  }
  function debug(message, ...data) {
    log("log", message, ...data);
  }
  function info(message, ...data) {
    log("log", message, ...data);
  }
  function warn(message, ...data) {
    log("warn", message, ...data);
  }
  function error(message, ...data) {
    log("error", message, ...data);
  }
  return {
    debug,
    info,
    warn,
    error
  };
}
function tryClone(data) {
  if (data === null || data === void 0 || data instanceof Error) {
    return data;
  }
  try {
    return structuredClone(data);
  } catch (err) {
    console.warn("Unable to clone data");
    return data;
  }
}

// src/utils/get-coordinate-distance.ts
function getCoordinateDistance(pointA, pointB) {
  return Math.sqrt(
    Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2)
  );
}

// src/utils/simple-hash.ts
function simpleHash(...args) {
  return JSON.stringify(
    args,
    (_, val) => typeof val === "object" ? val : String(val)
  );
}

// src/desktop/desktop-commands.ts
var logger = createLogger("desktop-commands");
var desktopCommands = {
  startWidget,
  startPreset,
  listenProvider,
  unlistenProvider,
  callProviderFunction,
  setAlwaysOnTop,
  setSkipTaskbar
};
function startWidget(configPath, placement) {
  return invoke("start_widget", { configPath, placement });
}
function startPreset(configPath, presetName) {
  return invoke("start_preset", { configPath, presetName });
}
function listenProvider(args) {
  return invoke("listen_provider", args);
}
function unlistenProvider(configHash) {
  return invoke("unlisten_provider", { configHash });
}
function callProviderFunction(configHash, fn) {
  return invoke("call_provider_function", {
    configHash,
    function: fn
  });
}
function setAlwaysOnTop() {
  return invoke("set_always_on_top");
}
function setSkipTaskbar(skip) {
  return invoke("set_skip_taskbar", { skip });
}
async function invoke(command, args) {
  logger.info(`Calling '${command}' with args:`, args ?? {});
  try {
    const response = await tauriInvoke(command, args);
    logger.info(`Response for calling '${command}':`, response);
    return response;
  } catch (err) {
    logger.error(`Command '${command}' failed: ${err}`);
    throw new Error(`Command '${command}' failed: ${err}`);
  }
}

// src/desktop/monitors.ts
import {
  availableMonitors as getAvailableMonitors,
  currentMonitor as getCurrentMonitor,
  primaryMonitor as getPrimaryMonitor,
  getCurrentWindow
} from "@tauri-apps/api/window";
var createCachePromise = null;
async function getMonitors() {
  return createCachePromise ?? (createCachePromise = createMonitorCache());
}
async function createMonitorCache() {
  const [currentMonitor, primaryMonitor, allMonitors] = await Promise.all([
    getCurrentMonitor(),
    getPrimaryMonitor(),
    getAvailableMonitors()
  ]);
  const secondaryMonitors = allMonitors.filter(
    (monitor) => !primaryMonitor || !isMatch(monitor, primaryMonitor)
  );
  const monitorCache = {
    currentMonitor: currentMonitor ? toMonitor(currentMonitor) : null,
    primaryMonitor: primaryMonitor ? toMonitor(primaryMonitor) : null,
    secondaryMonitors: secondaryMonitors.map(toMonitor),
    allMonitors: allMonitors.map(toMonitor)
  };
  getCurrentWindow().onResized(() => updateCurrentMonitor());
  getCurrentWindow().onMoved(() => updateCurrentMonitor());
  async function updateCurrentMonitor() {
    const currentMonitor2 = await getCurrentMonitor();
    Object.assign(monitorCache, {
      currentMonitor: currentMonitor2 ? toMonitor(currentMonitor2) : null
    });
  }
  return monitorCache;
}
function isMatch(monitorA, monitorB) {
  return monitorA.name === monitorB.name && monitorA.position.x === monitorB.position.x && monitorA.position.y === monitorB.position.y && monitorA.size.width === monitorB.size.width && monitorA.size.height === monitorB.size.height;
}
function toMonitor(monitor) {
  return {
    name: monitor.name,
    width: monitor.size.width,
    height: monitor.size.height,
    x: monitor.position.x,
    y: monitor.position.y,
    scaleFactor: monitor.scaleFactor
  };
}

// src/desktop/provider-emit.ts
import {
  listen
} from "@tauri-apps/api/event";
var logger2 = createLogger("desktop-events");
var listenPromise = null;
var callbacks = [];
async function onProviderEmit(config, callback) {
  const configHash = simpleHash(config);
  registerEventCallback(configHash, callback);
  const unlisten = await (listenPromise ?? (listenPromise = listenProviderEmit()));
  await desktopCommands.listenProvider({
    configHash,
    config
  });
  return async () => {
    callbacks = callbacks.filter(
      (callback2) => callback2.configHash !== configHash
    );
    await desktopCommands.unlistenProvider(configHash);
    if (callbacks.length === 0) {
      unlisten();
      listenPromise = null;
    }
  };
}
function registerEventCallback(configHash, callback) {
  const wrappedCallback = (event) => {
    if (event.payload.configHash !== configHash) {
      return;
    }
    logger2.debug("Incoming provider emission:", event.payload);
    callback(event.payload);
  };
  callbacks.push({ configHash, fn: wrappedCallback });
}
async function listenProviderEmit() {
  return listen("provider-emit", (event) => {
    callbacks.forEach((callback) => {
      if (event.payload.configHash === callback.configHash) {
        callback.fn(event);
      }
    });
  });
}

// src/desktop/widgets.ts
import { join } from "@tauri-apps/api/path";

// src/desktop/windows.ts
import { getCurrentWindow as getCurrentWindow2 } from "@tauri-apps/api/window";
function currentWindow() {
  return {
    get tauri() {
      return getCurrentWindow2();
    },
    setZOrder
  };
}
async function setZOrder(zOrder) {
  if (zOrder === "bottom_most") {
    await getCurrentWindow2().setAlwaysOnBottom(true);
  } else if (zOrder === "top_most") {
    await desktopCommands.setAlwaysOnTop();
  } else {
    await getCurrentWindow2().setAlwaysOnTop(false);
  }
}

// src/desktop/widgets.ts
function getWidgetState() {
  if (window.__ZEBAR_STATE) {
    return window.__ZEBAR_STATE;
  }
  const widgetState = sessionStorage.getItem("ZEBAR_STATE");
  if (!widgetState) {
    throw new Error("No widget state found.");
  }
  return JSON.parse(widgetState);
}
function currentWidget() {
  const state = getWidgetState();
  return {
    id: state.id,
    configPath: state.configPath,
    htmlPath: state.htmlPath,
    window: currentWindow()
  };
}
async function startWidget2(configPath, placement) {
  const filePath = configPath.endsWith(".zebar.json") ? configPath : `${configPath}.zebar.json`;
  const absolutePath = await join(
    getWidgetState().configPath,
    "../",
    filePath
  );
  return desktopCommands.startWidget(absolutePath, placement);
}
async function startWidgetPreset(configPath, presetName) {
  const filePath = configPath.endsWith(".zebar.json") ? configPath : `${configPath}.zebar.json`;
  const absolutePath = await join(
    getWidgetState().configPath,
    "../",
    filePath
  );
  return desktopCommands.startPreset(absolutePath, presetName);
}

// src/providers/audio/create-audio-provider.ts
import { z } from "zod";

// src/providers/create-base-provider.ts
function createBaseProvider(config, fetcher) {
  const outputListeners = /* @__PURE__ */ new Set();
  const errorListeners = /* @__PURE__ */ new Set();
  let latestEmission = {
    output: null,
    error: null,
    hasError: false
  };
  let unlisten = startFetcher();
  function startFetcher() {
    return fetcher({
      output: (output) => {
        latestEmission = { output, error: null, hasError: false };
        outputListeners.forEach((listener) => listener(output));
      },
      error: (error) => {
        latestEmission = { output: null, error, hasError: true };
        errorListeners.forEach((listener) => listener(error));
      }
    });
  }
  return {
    get output() {
      return latestEmission.output;
    },
    get error() {
      return latestEmission.error;
    },
    get hasError() {
      return latestEmission.hasError;
    },
    config,
    restart: async () => {
      if (unlisten) {
        await (await unlisten)();
      }
      unlisten = startFetcher();
    },
    stop: async () => {
      outputListeners.clear();
      errorListeners.clear();
      if (unlisten) {
        await (await unlisten)();
        unlisten = null;
      }
    },
    onOutput: (callback) => {
      outputListeners.add(callback);
    },
    onError: (callback) => {
      errorListeners.add(callback);
    }
  };
}

// src/providers/audio/create-audio-provider.ts
var audioProviderConfigSchema = z.object({
  type: z.literal("audio")
});
function createAudioProvider(config) {
  const mergedConfig = audioProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(
      mergedConfig,
      ({ configHash, result }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          queue.output({
            ...result.output,
            setVolume: (volume, options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "audio",
                function: {
                  name: "set_volume",
                  args: { volume, deviceId: options?.deviceId }
                }
              });
            }
          });
        }
      }
    );
  });
}

// src/providers/battery/create-battery-provider.ts
import { z as z2 } from "zod";
var batteryProviderConfigSchema = z2.object({
  type: z2.literal("battery"),
  refreshInterval: z2.coerce.number().default(60 * 1e3)
});
function createBatteryProvider(config) {
  const mergedConfig = batteryProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/cpu/create-cpu-provider.ts
import { z as z3 } from "zod";
var cpuProviderConfigSchema = z3.object({
  type: z3.literal("cpu"),
  refreshInterval: z3.coerce.number().default(5 * 1e3)
});
function createCpuProvider(config) {
  const mergedConfig = cpuProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/date/create-date-provider.ts
import { DateTime } from "luxon";
import { z as z4 } from "zod";
var dateProviderConfigSchema = z4.object({
  type: z4.literal("date"),
  refreshInterval: z4.coerce.number().default(1e3),
  timezone: z4.string().default("local"),
  locale: z4.string().optional(),
  formatting: z4.string().default("EEE	d MMM t")
});
function createDateProvider(config) {
  const mergedConfig = dateProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    queue.output(getDateValue());
    const interval = setInterval(
      () => queue.output(getDateValue()),
      mergedConfig.refreshInterval
    );
    function getDateValue() {
      const dateTime = DateTime.now().setZone(mergedConfig.timezone);
      return {
        new: dateTime.toJSDate(),
        now: dateTime.toMillis(),
        iso: dateTime.toISO(),
        formatted: dateTime.toFormat(mergedConfig.formatting, {
          locale: mergedConfig.locale
        })
      };
    }
    return () => {
      clearInterval(interval);
    };
  });
}

// src/providers/glazewm/create-glazewm-provider.ts
import {
  WmClient,
  WmEventType
} from "glazewm";
import { z as z5 } from "zod";
var glazeWmProviderConfigSchema = z5.object({
  type: z5.literal("glazewm")
});
function createGlazeWmProvider(config) {
  const mergedConfig = glazeWmProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    const monitors = await getMonitors();
    const client = new WmClient();
    let unlistenEvents = null;
    client.onDisconnect(
      () => queue.error("Failed to connect to GlazeWM IPC server.")
    );
    client.onConnect(async () => {
      let state = await getInitialState();
      queue.output(state);
      unlistenEvents ??= await client.subscribe(WmEventType.ALL, onEvent);
      async function onEvent(e) {
        switch (e.eventType) {
          case WmEventType.BINDING_MODES_CHANGED: {
            state = { ...state, bindingModes: e.newBindingModes };
            break;
          }
          case WmEventType.FOCUS_CHANGED: {
            state = { ...state, focusedContainer: e.focusedContainer };
            state = { ...state, ...await getMonitorState() };
            const { tilingDirection } = await client.queryTilingDirection();
            state = { ...state, tilingDirection };
            break;
          }
          case WmEventType.FOCUSED_CONTAINER_MOVED: {
            state = { ...state, focusedContainer: e.focusedContainer };
            state = { ...state, ...await getMonitorState() };
            break;
          }
          case WmEventType.TILING_DIRECTION_CHANGED: {
            state = { ...state, tilingDirection: e.newTilingDirection };
            break;
          }
          case WmEventType.WORKSPACE_ACTIVATED:
          case WmEventType.WORKSPACE_DEACTIVATED:
          case WmEventType.WORKSPACE_UPDATED: {
            state = { ...state, ...await getMonitorState() };
            break;
          }
          case WmEventType.PAUSE_CHANGED: {
            state = { ...state, isPaused: e.isPaused };
            break;
          }
        }
        queue.output(state);
      }
      function runCommand(command, subjectContainerId) {
        return client.runCommand(command, subjectContainerId);
      }
      async function getInitialState() {
        const { focused: focusedContainer } = await client.queryFocused();
        const { bindingModes } = await client.queryBindingModes();
        const { tilingDirection } = await client.queryTilingDirection();
        const isPaused = await getIsPaused();
        return {
          ...await getMonitorState(),
          focusedContainer,
          tilingDirection,
          bindingModes,
          isPaused,
          runCommand
        };
      }
      async function getIsPaused() {
        try {
          const { paused } = await client.queryPaused();
          return paused;
        } catch {
          return false;
        }
      }
      async function getMonitorState() {
        const currentPosition = {
          x: monitors.currentMonitor.x,
          y: monitors.currentMonitor.y
        };
        const { monitors: glazeWmMonitors } = await client.queryMonitors();
        const { windows: glazeWmWindows } = await client.queryWindows();
        const currentGlazeWmMonitor = glazeWmMonitors.reduce(
          (a, b) => getCoordinateDistance(currentPosition, a) < getCoordinateDistance(currentPosition, b) ? a : b
        );
        const focusedGlazeWmMonitor = glazeWmMonitors.find(
          (monitor) => monitor.hasFocus
        );
        const allGlazeWmWorkspaces = glazeWmMonitors.flatMap(
          (monitor) => monitor.children
        );
        const focusedGlazeWmWorkspace = focusedGlazeWmMonitor?.children.find(
          (workspace) => workspace.hasFocus
        );
        const displayedGlazeWmWorkspace = currentGlazeWmMonitor.children.find(
          (workspace) => workspace.isDisplayed
        );
        return {
          displayedWorkspace: displayedGlazeWmWorkspace,
          focusedWorkspace: focusedGlazeWmWorkspace,
          currentWorkspaces: currentGlazeWmMonitor.children,
          allWorkspaces: allGlazeWmWorkspaces,
          focusedMonitor: focusedGlazeWmMonitor,
          currentMonitor: currentGlazeWmMonitor,
          allMonitors: glazeWmMonitors,
          allWindows: glazeWmWindows
        };
      }
    });
    return () => {
      unlistenEvents?.();
      client.closeConnection();
    };
  });
}

// src/providers/host/create-host-provider.ts
import { z as z6 } from "zod";
var hostProviderConfigSchema = z6.object({
  type: z6.literal("host"),
  refreshInterval: z6.coerce.number().default(60 * 1e3)
});
function createHostProvider(config) {
  const mergedConfig = hostProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/ip/create-ip-provider.ts
import { z as z7 } from "zod";
var ipProviderConfigSchema = z7.object({
  type: z7.literal("ip"),
  refreshInterval: z7.coerce.number().default(60 * 60 * 1e3)
});
function createIpProvider(config) {
  const mergedConfig = ipProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/keyboard/create-keyboard-provider.ts
import { z as z8 } from "zod";
var keyboardProviderConfigSchema = z8.object({
  type: z8.literal("keyboard"),
  refreshInterval: z8.coerce.number().default(1e3)
});
function createKeyboardProvider(config) {
  const mergedConfig = keyboardProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/komorebi/create-komorebi-provider.ts
import { z as z9 } from "zod";
var komorebiProviderConfigSchema = z9.object({
  type: z9.literal("komorebi")
});
function createKomorebiProvider(config) {
  const mergedConfig = komorebiProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    const monitors = await getMonitors();
    async function getUpdatedState(res) {
      const currentPosition = {
        x: monitors.currentMonitor.x,
        y: monitors.currentMonitor.y
      };
      const currentKomorebiMonitor = res.allMonitors.reduce(
        (a, b) => getCoordinateDistance(currentPosition, {
          x: a.workAreaSize.left,
          y: a.workAreaSize.top
        }) < getCoordinateDistance(currentPosition, {
          x: b.workAreaSize.left,
          y: b.workAreaSize.top
        }) ? a : b
      );
      const displayedKomorebiWorkspace = currentKomorebiMonitor.workspaces[currentKomorebiMonitor.focusedWorkspaceIndex];
      const allKomorebiWorkspaces = res.allMonitors.flatMap(
        (monitor) => monitor.workspaces
      );
      const focusedKomorebiMonitor = res.allMonitors[res.focusedMonitorIndex];
      const focusedKomorebiWorkspace = focusedKomorebiMonitor.workspaces[focusedKomorebiMonitor.focusedWorkspaceIndex];
      return {
        displayedWorkspace: displayedKomorebiWorkspace,
        focusedWorkspace: focusedKomorebiWorkspace,
        currentWorkspaces: currentKomorebiMonitor.workspaces,
        allWorkspaces: allKomorebiWorkspaces,
        focusedMonitor: focusedKomorebiMonitor,
        currentMonitor: currentKomorebiMonitor,
        allMonitors: res.allMonitors
      };
    }
    return onProviderEmit(
      mergedConfig,
      async ({ result }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          const updatedState = await getUpdatedState(result.output);
          queue.output(updatedState);
        }
      }
    );
  });
}

// src/providers/media/create-media-provider.ts
import { z as z10 } from "zod";
var mediaProviderConfigSchema = z10.object({
  type: z10.literal("media")
});
function createMediaProvider(config) {
  const mergedConfig = mediaProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(
      mergedConfig,
      ({ result, configHash }) => {
        if ("error" in result) {
          queue.error(result.error);
        } else {
          queue.output({
            ...result.output,
            session: result.output.currentSession,
            play: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "play",
                  args: options ?? {}
                }
              });
            },
            pause: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "pause",
                  args: options ?? {}
                }
              });
            },
            togglePlayPause: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "toggle_play_pause",
                  args: options ?? {}
                }
              });
            },
            next: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "next",
                  args: options ?? {}
                }
              });
            },
            previous: (options) => {
              return desktopCommands.callProviderFunction(configHash, {
                type: "media",
                function: {
                  name: "previous",
                  args: options ?? {}
                }
              });
            }
          });
        }
      }
    );
  });
}

// src/providers/memory/create-memory-provider.ts
import { z as z11 } from "zod";
var memoryProviderConfigSchema = z11.object({
  type: z11.literal("memory"),
  refreshInterval: z11.coerce.number().default(5 * 1e3)
});
function createMemoryProvider(config) {
  const mergedConfig = memoryProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/network/create-network-provider.ts
import { z as z12 } from "zod";
var networkProviderConfigSchema = z12.object({
  type: z12.literal("network"),
  refreshInterval: z12.coerce.number().default(5 * 1e3)
});
function createNetworkProvider(config) {
  const mergedConfig = networkProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/weather/create-weather-provider.ts
import { z as z13 } from "zod";
var weatherProviderConfigSchema = z13.object({
  type: z13.literal("weather"),
  latitude: z13.coerce.number().optional(),
  longitude: z13.coerce.number().optional(),
  refreshInterval: z13.coerce.number().default(60 * 60 * 1e3)
});
function createWeatherProvider(config) {
  const mergedConfig = weatherProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/disk/create-disk-provider.ts
import { z as z14 } from "zod";
var diskProviderConfigSchema = z14.object({
  type: z14.literal("disk"),
  refreshInterval: z14.coerce.number().default(60 * 1e3)
});
function createDiskProvider(config) {
  const mergedConfig = diskProviderConfigSchema.parse(config);
  return createBaseProvider(mergedConfig, async (queue) => {
    return onProviderEmit(mergedConfig, ({ result }) => {
      if ("error" in result) {
        queue.error(result.error);
      } else {
        queue.output(result.output);
      }
    });
  });
}

// src/providers/create-provider.ts
function createProvider(config) {
  switch (config.type) {
    case "audio":
      return createAudioProvider(config);
    case "battery":
      return createBatteryProvider(config);
    case "cpu":
      return createCpuProvider(config);
    case "date":
      return createDateProvider(config);
    case "glazewm":
      return createGlazeWmProvider(config);
    case "host":
      return createHostProvider(config);
    case "ip":
      return createIpProvider(config);
    case "komorebi":
      return createKomorebiProvider(config);
    case "media":
      return createMediaProvider(config);
    case "memory":
      return createMemoryProvider(config);
    case "network":
      return createNetworkProvider(config);
    case "weather":
      return createWeatherProvider(config);
    case "keyboard":
      return createKeyboardProvider(config);
    case "disk":
      return createDiskProvider(config);
    default:
      throw new Error("Not a supported provider type.");
  }
}

// src/providers/create-provider-group.ts
function createProviderGroup(configMap) {
  const outputListeners = /* @__PURE__ */ new Set();
  const errorListeners = /* @__PURE__ */ new Set();
  const providerMap = createProviderMap(configMap);
  let outputMap = Object.fromEntries(
    Object.keys(providerMap).map((name) => [name, null])
  );
  let errorMap = Object.fromEntries(
    Object.keys(providerMap).map((name) => [name, null])
  );
  for (const [name, provider] of Object.entries(providerMap)) {
    provider.onOutput(() => {
      outputMap = { ...outputMap, [name]: provider.output };
      errorMap = { ...errorMap, [name]: null };
      outputListeners.forEach((listener) => listener(outputMap));
    });
    provider.onError(() => {
      errorMap = { ...errorMap, [name]: provider.error };
      outputMap = { ...outputMap, [name]: null };
      errorListeners.forEach((listener) => listener(errorMap));
    });
  }
  return {
    get outputMap() {
      return outputMap;
    },
    get errorMap() {
      return errorMap;
    },
    get hasErrors() {
      return Object.keys(errorMap).length > 0;
    },
    configMap,
    raw: providerMap,
    onOutput: (callback) => {
      outputListeners.add(callback);
    },
    onError: (callback) => {
      errorListeners.add(callback);
    },
    restartAll: async () => {
      await Promise.all(
        Object.values(providerMap).map((provider) => provider.restart())
      );
    },
    stopAll: async () => {
      outputListeners.clear();
      errorListeners.clear();
      await Promise.all(
        Object.values(providerMap).map((provider) => provider.stop())
      );
    }
  };
}
function createProviderMap(configMap) {
  return Object.fromEntries(
    Object.entries(configMap).map(([name, config]) => [
      name,
      createProvider(config)
    ])
  );
}
export {
  createProvider,
  createProviderGroup,
  currentWidget,
  startWidget2 as startWidget,
  startWidgetPreset
};
